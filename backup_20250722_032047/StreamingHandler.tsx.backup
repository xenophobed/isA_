/**
 * ============================================================================
 * 流式数据处理器 (StreamingHandler.tsx)
 * ============================================================================
 * 
 * 【核心功能】
 * - 监听SimpleAI客户端的所有流式事件
 * - 管理聊天界面的实时消息显示
 * - 协调流式token接收、状态更新、消息完成等流程
 * - 处理批量token优化和性能提升
 * 
 * 【关键职责】
 * - streaming:start → 创建流式消息UI (startStreamingMessage)
 * - token:received → 实时追加内容 (appendToStreamingMessage) 
 * - streaming:status → 更新状态显示 (updateStreamingStatus)
 * - streaming:finish → 完成流式显示 (finishStreamingMessage)
 * - message:received → 处理最终AI回复
 * - custom_event → 解析工作流状态和批量token
 * 
 * 【消息显示逻辑】
 * 只在主聊天界面(!showRightSidebar && !currentApp)时处理消息显示
 * 当有应用打开时，让应用自己处理消息
 * 
 * 【流式处理流程】
 * 1. 接收streaming:start → 创建空的assistant消息
 * 2. 接收token:received → 逐步追加内容到消息
 * 3. 接收streaming:status → 更新消息状态文本
 * 4. 接收streaming:finish → 标记消息完成
 * 
 * 【性能优化】
 * - 支持批量token处理(response_batch)
 * - 减少高频事件的日志输出
 * - 优化UI更新频率
 */
import React, { useEffect } from 'react';
import { useSimpleAI } from '../../providers/SimpleAIProvider';
import { useChatActions } from '../../stores/useAppStore';

interface StreamingHandlerProps {
  showRightSidebar: boolean;
  currentApp: string | null;
}

export const StreamingHandler: React.FC<StreamingHandlerProps> = ({
  showRightSidebar,
  currentApp
}) => {
  const client = useSimpleAI();
  const { 
    startStreamingMessage, 
    appendToStreamingMessage, 
    finishStreamingMessage, 
    updateStreamingStatus
  } = useChatActions();

  useEffect(() => {
    if (!client || client.isDestroyed()) {
      console.log('⚠️ StreamingHandler: Client not available or destroyed');
      return;
    }

    console.log('🔗 StreamingHandler: Setting up event listeners');

    const handleStreamingStart = (data: any) => {
      console.log('🎬 STREAMING: Started', data, 'showRightSidebar:', showRightSidebar, 'currentApp:', currentApp);
      if (!showRightSidebar && !currentApp) {
        const messageId = `streaming-${Date.now()}`;
        console.log('✅ STREAMING: Creating streaming message UI with ID:', messageId);
        startStreamingMessage(messageId, 'Contacting AI...');
        console.log('📋 STREAMING: Message created, ready to receive tokens');
      } else {
        console.log('❌ STREAMING: Skipping streaming UI (app open or sidebar visible)');
      }
    };

    const handleStreamingToken = (data: any) => {
      // Optimize logging for batch tokens to reduce console spam
      if (data.count && data.count > 1) {
        console.log(`🚀 STREAMING: Batch received (${data.count} chars, total: ${data.total_index})`);
      } else {
        console.log('🔤 STREAMING: Token received', data);
      }
      
      if (!showRightSidebar && !currentApp) {
        console.log('📝 STREAMING: Appending content to message:', data.content);
        appendToStreamingMessage(data.content || '');
        // Less frequent status updates for better performance
        if (data.count && data.count > 1) {
          updateStreamingStatus(`🚀 Streaming... (${data.total_index} chars)`);
        } else {
          updateStreamingStatus('🔤 Streaming...');
        }
      } else {
        console.log('❌ STREAMING: Skipping token append (sidebar or app active)', { showRightSidebar, currentApp });
      }
    };

    const handleCustomEvent = (data: any) => {
      console.log('🔧 CUSTOM EVENT:', data);
      
      if (!showRightSidebar && !currentApp) {
        try {
          if (data.metadata?.raw_chunk) {
            const chunk = data.metadata.raw_chunk;
            
            // Handle batch token streaming updates
            if (chunk.response_batch && chunk.response_batch.status === 'streaming') {
              updateStreamingStatus(`🚀 Streaming (${chunk.response_batch.total_index} chars)`);
            }
            
            if (chunk.entry_preparation) {
              if (chunk.entry_preparation.status === 'starting') {
                updateStreamingStatus('🔸 Preparing request...');
              } else if (chunk.entry_preparation.status === 'completed') {
                updateStreamingStatus('✅ Request prepared');
              }
            }
            
            if (chunk.autonomous_task) {
              const task = chunk.autonomous_task;
              if (task.status === 'starting') {
                updateStreamingStatus(`🤖 Task ${task.task_index}/${task.total_tasks}: ${task.task_title}`);
              } else if (task.status === 'completed') {
                updateStreamingStatus(`✅ Completed: ${task.task_title}`);
              }
            }
          }
        } catch (e) {
          console.log('Failed to parse custom event:', e);
        }
      }
    };

    const handleStreamingStatus = (data: any) => {
      console.log('📊 STREAMING: Status update', data);
      if (!showRightSidebar && !currentApp) {
        const status = data.status || data.message || 'processing';
        updateStreamingStatus(status);
      }
    };

    const handleStreamingEnd = (data: any) => {
      console.log('🏁 STREAMING: Ended', data);
      finishStreamingMessage();
    };

    const handleStreamingFinish = (data: any) => {
      console.log('🏁 STREAMING: Finished', data);
      finishStreamingMessage();
    };

    const handleMessageReceived = (message: any) => {
      console.log('📨 STREAMING HANDLER: Received final message - BLOCKING IT:', message);
      
      // COMPLETELY BLOCK final assistant messages - only use streaming system
      if (message.role === 'assistant' && !message.metadata?.sender) {
        if (!showRightSidebar && !currentApp) {
          console.log('🚫 STREAMING: BLOCKING final message - only using streaming tokens');
          // Do NOT add the message - streaming system handles everything
          return;
        }
      }
    };

    const unsubscribeStart = client.on('streaming:start', handleStreamingStart);
    const unsubscribeToken = client.on('token:received', handleStreamingToken);
    const unsubscribeCustom = client.on('custom_event', handleCustomEvent);
    const unsubscribeStatus = client.on('streaming:status', handleStreamingStatus);
    const unsubscribeEnd = client.on('streaming:end', handleStreamingEnd);
    const unsubscribeFinish = client.on('streaming:finish', handleStreamingFinish);
    const unsubscribeMessage = client.on('message:received', handleMessageReceived);

    return () => {
      console.log('🧹 StreamingHandler: Cleaning up event listeners');
      unsubscribeStart?.();
      unsubscribeToken?.();
      unsubscribeCustom?.();
      unsubscribeStatus?.();
      unsubscribeEnd?.();
      unsubscribeFinish?.();
      unsubscribeMessage?.();
    };
  }, [client, startStreamingMessage, appendToStreamingMessage, finishStreamingMessage, updateStreamingStatus, showRightSidebar, currentApp]);

  return null;
};