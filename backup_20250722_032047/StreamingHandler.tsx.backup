/**
 * ============================================================================
 * æµå¼æ•°æ®å¤„ç†å™¨ (StreamingHandler.tsx)
 * ============================================================================
 * 
 * ã€æ ¸å¿ƒåŠŸèƒ½ã€‘
 * - ç›‘å¬SimpleAIå®¢æˆ·ç«¯çš„æ‰€æœ‰æµå¼äº‹ä»¶
 * - ç®¡ç†èŠå¤©ç•Œé¢çš„å®æ—¶æ¶ˆæ¯æ˜¾ç¤º
 * - åè°ƒæµå¼tokenæ¥æ”¶ã€çŠ¶æ€æ›´æ–°ã€æ¶ˆæ¯å®Œæˆç­‰æµç¨‹
 * - å¤„ç†æ‰¹é‡tokenä¼˜åŒ–å’Œæ€§èƒ½æå‡
 * 
 * ã€å…³é”®èŒè´£ã€‘
 * - streaming:start â†’ åˆ›å»ºæµå¼æ¶ˆæ¯UI (startStreamingMessage)
 * - token:received â†’ å®æ—¶è¿½åŠ å†…å®¹ (appendToStreamingMessage) 
 * - streaming:status â†’ æ›´æ–°çŠ¶æ€æ˜¾ç¤º (updateStreamingStatus)
 * - streaming:finish â†’ å®Œæˆæµå¼æ˜¾ç¤º (finishStreamingMessage)
 * - message:received â†’ å¤„ç†æœ€ç»ˆAIå›å¤
 * - custom_event â†’ è§£æå·¥ä½œæµçŠ¶æ€å’Œæ‰¹é‡token
 * 
 * ã€æ¶ˆæ¯æ˜¾ç¤ºé€»è¾‘ã€‘
 * åªåœ¨ä¸»èŠå¤©ç•Œé¢(!showRightSidebar && !currentApp)æ—¶å¤„ç†æ¶ˆæ¯æ˜¾ç¤º
 * å½“æœ‰åº”ç”¨æ‰“å¼€æ—¶ï¼Œè®©åº”ç”¨è‡ªå·±å¤„ç†æ¶ˆæ¯
 * 
 * ã€æµå¼å¤„ç†æµç¨‹ã€‘
 * 1. æ¥æ”¶streaming:start â†’ åˆ›å»ºç©ºçš„assistantæ¶ˆæ¯
 * 2. æ¥æ”¶token:received â†’ é€æ­¥è¿½åŠ å†…å®¹åˆ°æ¶ˆæ¯
 * 3. æ¥æ”¶streaming:status â†’ æ›´æ–°æ¶ˆæ¯çŠ¶æ€æ–‡æœ¬
 * 4. æ¥æ”¶streaming:finish â†’ æ ‡è®°æ¶ˆæ¯å®Œæˆ
 * 
 * ã€æ€§èƒ½ä¼˜åŒ–ã€‘
 * - æ”¯æŒæ‰¹é‡tokenå¤„ç†(response_batch)
 * - å‡å°‘é«˜é¢‘äº‹ä»¶çš„æ—¥å¿—è¾“å‡º
 * - ä¼˜åŒ–UIæ›´æ–°é¢‘ç‡
 */
import React, { useEffect } from 'react';
import { useSimpleAI } from '../../providers/SimpleAIProvider';
import { useChatActions } from '../../stores/useAppStore';

interface StreamingHandlerProps {
  showRightSidebar: boolean;
  currentApp: string | null;
}

export const StreamingHandler: React.FC<StreamingHandlerProps> = ({
  showRightSidebar,
  currentApp
}) => {
  const client = useSimpleAI();
  const { 
    startStreamingMessage, 
    appendToStreamingMessage, 
    finishStreamingMessage, 
    updateStreamingStatus
  } = useChatActions();

  useEffect(() => {
    if (!client || client.isDestroyed()) {
      console.log('âš ï¸ StreamingHandler: Client not available or destroyed');
      return;
    }

    console.log('ğŸ”— StreamingHandler: Setting up event listeners');

    const handleStreamingStart = (data: any) => {
      console.log('ğŸ¬ STREAMING: Started', data, 'showRightSidebar:', showRightSidebar, 'currentApp:', currentApp);
      if (!showRightSidebar && !currentApp) {
        const messageId = `streaming-${Date.now()}`;
        console.log('âœ… STREAMING: Creating streaming message UI with ID:', messageId);
        startStreamingMessage(messageId, 'Contacting AI...');
        console.log('ğŸ“‹ STREAMING: Message created, ready to receive tokens');
      } else {
        console.log('âŒ STREAMING: Skipping streaming UI (app open or sidebar visible)');
      }
    };

    const handleStreamingToken = (data: any) => {
      // Optimize logging for batch tokens to reduce console spam
      if (data.count && data.count > 1) {
        console.log(`ğŸš€ STREAMING: Batch received (${data.count} chars, total: ${data.total_index})`);
      } else {
        console.log('ğŸ”¤ STREAMING: Token received', data);
      }
      
      if (!showRightSidebar && !currentApp) {
        console.log('ğŸ“ STREAMING: Appending content to message:', data.content);
        appendToStreamingMessage(data.content || '');
        // Less frequent status updates for better performance
        if (data.count && data.count > 1) {
          updateStreamingStatus(`ğŸš€ Streaming... (${data.total_index} chars)`);
        } else {
          updateStreamingStatus('ğŸ”¤ Streaming...');
        }
      } else {
        console.log('âŒ STREAMING: Skipping token append (sidebar or app active)', { showRightSidebar, currentApp });
      }
    };

    const handleCustomEvent = (data: any) => {
      console.log('ğŸ”§ CUSTOM EVENT:', data);
      
      if (!showRightSidebar && !currentApp) {
        try {
          if (data.metadata?.raw_chunk) {
            const chunk = data.metadata.raw_chunk;
            
            // Handle batch token streaming updates
            if (chunk.response_batch && chunk.response_batch.status === 'streaming') {
              updateStreamingStatus(`ğŸš€ Streaming (${chunk.response_batch.total_index} chars)`);
            }
            
            if (chunk.entry_preparation) {
              if (chunk.entry_preparation.status === 'starting') {
                updateStreamingStatus('ğŸ”¸ Preparing request...');
              } else if (chunk.entry_preparation.status === 'completed') {
                updateStreamingStatus('âœ… Request prepared');
              }
            }
            
            if (chunk.autonomous_task) {
              const task = chunk.autonomous_task;
              if (task.status === 'starting') {
                updateStreamingStatus(`ğŸ¤– Task ${task.task_index}/${task.total_tasks}: ${task.task_title}`);
              } else if (task.status === 'completed') {
                updateStreamingStatus(`âœ… Completed: ${task.task_title}`);
              }
            }
          }
        } catch (e) {
          console.log('Failed to parse custom event:', e);
        }
      }
    };

    const handleStreamingStatus = (data: any) => {
      console.log('ğŸ“Š STREAMING: Status update', data);
      if (!showRightSidebar && !currentApp) {
        const status = data.status || data.message || 'processing';
        updateStreamingStatus(status);
      }
    };

    const handleStreamingEnd = (data: any) => {
      console.log('ğŸ STREAMING: Ended', data);
      finishStreamingMessage();
    };

    const handleStreamingFinish = (data: any) => {
      console.log('ğŸ STREAMING: Finished', data);
      finishStreamingMessage();
    };

    const handleMessageReceived = (message: any) => {
      console.log('ğŸ“¨ STREAMING HANDLER: Received final message - BLOCKING IT:', message);
      
      // COMPLETELY BLOCK final assistant messages - only use streaming system
      if (message.role === 'assistant' && !message.metadata?.sender) {
        if (!showRightSidebar && !currentApp) {
          console.log('ğŸš« STREAMING: BLOCKING final message - only using streaming tokens');
          // Do NOT add the message - streaming system handles everything
          return;
        }
      }
    };

    const unsubscribeStart = client.on('streaming:start', handleStreamingStart);
    const unsubscribeToken = client.on('token:received', handleStreamingToken);
    const unsubscribeCustom = client.on('custom_event', handleCustomEvent);
    const unsubscribeStatus = client.on('streaming:status', handleStreamingStatus);
    const unsubscribeEnd = client.on('streaming:end', handleStreamingEnd);
    const unsubscribeFinish = client.on('streaming:finish', handleStreamingFinish);
    const unsubscribeMessage = client.on('message:received', handleMessageReceived);

    return () => {
      console.log('ğŸ§¹ StreamingHandler: Cleaning up event listeners');
      unsubscribeStart?.();
      unsubscribeToken?.();
      unsubscribeCustom?.();
      unsubscribeStatus?.();
      unsubscribeEnd?.();
      unsubscribeFinish?.();
      unsubscribeMessage?.();
    };
  }, [client, startStreamingMessage, appendToStreamingMessage, finishStreamingMessage, updateStreamingStatus, showRightSidebar, currentApp]);

  return null;
};