/**
 * ============================================================================
 * 基础侧边栏组件 (BaseSidebar.tsx)
 * ============================================================================
 * 
 * 【核心功能】
 * - 提供统一的侧边栏基础架构
 * - 管理AI客户端连接和事件监听
 * - 处理应用级别的消息交互和状态管理
 * - 支持流式显示和错误处理
 * 
 * 【关键监听事件】
 * - streaming:start → 开始流式显示
 * - token:received → 接收实时token
 * - streaming:status → 状态更新
 * - streaming:finish → 完成流式显示
 * - message:received (第168行) → 接收最终AI消息
 * 
 * 【消息处理逻辑】
 * 第168-198行：监听message:received事件
 * 只更新内部状态，不添加到聊天消息数组
 * 
 * 【流式显示】
 * 第260-271行：显示实时流式内容预览
 * 包括状态文本和字符计数
 * 
 * 【重要】这里不会创建聊天消息，只处理侧边栏内部状态
 */
import React, { useState, useCallback, memo, useEffect } from 'react';
import { SimpleAIClient } from '../../services/SimpleAIClient';
import { useErrorHandler } from './ErrorBoundary';
import { validateUserInput, globalRateLimiter, generateSessionId } from '../../utils/security';
import { useAuth } from '../../hooks/useAuth';

export interface BaseSidebarProps {
  title: string;
  icon: string;
  triggeredInput?: string;
  onResult?: (result: any) => void;
  onError?: (error: Error) => void;
  children?: React.ReactNode;
  apiEndpoint?: string;
}

interface SidebarState {
  isProcessing: boolean;
  error: string | null;
  result: any;
  // 流式显示相关状态
  streamingContent: string;
  streamingStatus: string;
  isStreaming: boolean;
}

/**
 * 通用 Sidebar 基础组件
 * 提供统一的状态管理、错误处理和 AI 客户端管理
 */
export const BaseSidebar = memo<BaseSidebarProps>(({
  title,
  icon,
  triggeredInput,
  onResult,
  onError,
  children,
  apiEndpoint = process.env.REACT_APP_API_ENDPOINT || 'http://localhost:8080'
}) => {
  const [client] = useState(() => new SimpleAIClient(apiEndpoint));
  const { user } = useAuth();
  const [state, setState] = useState<SidebarState>({
    isProcessing: false,
    error: null,
    result: null,
    streamingContent: '',
    streamingStatus: '',
    isStreaming: false
  });
  
  const { handleError } = useErrorHandler();

  // 设置流式事件监听器
  useEffect(() => {
    if (!client) return;

    console.log(`🔗 BASESIDEBAR [${title}]: Setting up streaming event listeners`);

    // 监听流式开始
    const unsubscribeStreamingStart = client.on('streaming:start', (data) => {
      console.log(`🎬 BASESIDEBAR [${title}]: Streaming started`, data);
      setState(prev => ({
        ...prev,
        isStreaming: true,
        streamingContent: '',
        streamingStatus: 'Connecting to AI...'
      }));
    });

    // 监听实时token (支持批量和单个)
    const unsubscribeToken = client.on('token:received', (data) => {
      // Optimize logging for batch processing
      if (data.count && data.count > 1) {
        console.log(`🚀 BASESIDEBAR [${title}]: Batch received (${data.count} chars, total: ${data.total_index})`);
      } else {
        console.log(`🔤 BASESIDEBAR [${title}]: Token received:`, data.content);
      }
      
      setState(prev => {
        const newContent = prev.streamingContent + (data.content || '');
        // Update status less frequently for batch processing
        const newStatus = data.count && data.count > 1 
          ? `Generating response... (${data.total_index || newContent.length} chars)`
          : 'Generating response...';
        
        return {
          ...prev,
          streamingContent: newContent,
          streamingStatus: newStatus
        };
      });
    });

    // 监听状态更新
    const unsubscribeStatus = client.on('streaming:status', (data) => {
      console.log(`📊 BASESIDEBAR [${title}]: Status update:`, data.status);
      setState(prev => ({
        ...prev,
        streamingStatus: data.status || 'Processing...'
      }));
    });

    // 监听流式结束
    const unsubscribeStreamingFinish = client.on('streaming:finish', (data) => {
      console.log(`🏁 BASESIDEBAR [${title}]: Streaming finished`, data);
      setState(prev => ({
        ...prev,
        isStreaming: false,
        streamingStatus: 'Completing...'
      }));
    });

    return () => {
      console.log(`🧹 BASESIDEBAR [${title}]: Cleaning up streaming listeners`);
      unsubscribeStreamingStart?.();
      unsubscribeToken?.();
      unsubscribeStatus?.();
      unsubscribeStreamingFinish?.();
    };
  }, [client, title]);

  // 统一的处理函数
  const handleProcess = useCallback(async (
    input: string,
    templateParams?: Record<string, any>,
    metadata?: Record<string, any>
  ) => {
    if (!input.trim()) return;

    // 安全验证
    const validation = validateUserInput(input);
    if (!validation.isValid) {
      setState(prev => ({ ...prev, error: validation.error || 'Invalid input' }));
      return;
    }

    // 请求频率限制
    const sessionId = generateSessionId();
    const rateLimitCheck = globalRateLimiter.checkLimit(sessionId);
    if (!rateLimitCheck.allowed) {
      setState(prev => ({ ...prev, error: 'Too many requests. Please try again later.' }));
      return;
    }

    setState(prev => ({ 
      ...prev, 
      isProcessing: true, 
      error: null,
      streamingContent: '',
      streamingStatus: 'Preparing request...',
      isStreaming: false
    }));

    try {
      const requestMetadata = {
        sender: title.toLowerCase().replace(/\s+/g, '_'),
        template_parameters: templateParams,
        user_id: user?.user_id || 'anonymous',
        session_id: 'app_session',
        ...metadata
      };

      // 使用清理后的输入
      const cleanInput = validation.sanitized || input;
      await client.sendMessage(cleanInput, requestMetadata);
      
      // 设置消息接收监听器
      const unsubscribe = client.on('message:received', (message) => {
        try {
          console.log('📨 BASESIDEBAR: Received message:', {
            title,
            sender: message.metadata?.sender,
            content: message.content?.substring(0, 100) + '...',
            isProcessing: true
          });
          
          setState(prev => ({ 
            ...prev, 
            isProcessing: false, 
            result: message,
            error: null 
          }));
          
          console.log('✅ BASESIDEBAR: Set isProcessing to false for:', title);
          
          onResult?.(message);
          unsubscribe(); // 清理监听器
        } catch (error) {
          const err = error instanceof Error ? error : new Error(String(error));
          handleError(err, `${title} result processing`);
          onError?.(err);
          setState(prev => ({ 
            ...prev, 
            isProcessing: false, 
            error: err.message 
          }));
        }
      });

      // 设置超时清理
      setTimeout(() => {
        unsubscribe();
        if (state.isProcessing) {
          setState(prev => ({ 
            ...prev, 
            isProcessing: false, 
            error: 'Request timeout' 
          }));
        }
      }, 30000); // 30秒超时

    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      handleError(err, `${title} request`);
      onError?.(err);
      setState(prev => ({ 
        ...prev, 
        isProcessing: false, 
        error: err.message 
      }));
    }
  }, [client, title, onResult, onError, handleError, state.isProcessing]);

  // 重置状态
  const handleReset = useCallback(() => {
    setState({
      isProcessing: false,
      error: null,
      result: null,
      streamingContent: '',
      streamingStatus: '',
      isStreaming: false
    });
  }, []);

  // 自动处理触发输入
  React.useEffect(() => {
    if (triggeredInput && !state.isProcessing) {
      handleProcess(triggeredInput);
    }
  }, [triggeredInput, handleProcess, state.isProcessing]);

  return (
    <div className="h-full flex flex-col bg-black/20 backdrop-blur-xl">
      {/* Header */}
      <div className="p-6 border-b border-white/10">
        <div className="flex items-center gap-3 mb-2">
          <span className="text-2xl">{icon}</span>
          <h2 className="text-xl font-bold text-white">{title}</h2>
        </div>
        
        {state.isProcessing && (
          <div className="flex items-center gap-2 text-blue-400 text-sm">
            <div className="w-4 h-4 border-2 border-blue-400 border-t-transparent rounded-full animate-spin"></div>
            {state.isStreaming ? state.streamingStatus : 'Processing...'}
          </div>
        )}
        
        {/* 流式内容预览 (优化版) */}
        {state.isStreaming && state.streamingContent && (
          <div className="mt-3 p-3 bg-blue-500/10 border border-blue-500/20 rounded-lg">
            <div className="text-xs text-blue-300 mb-1 flex items-center justify-between">
              <span>Real-time Response:</span>
              <span className="text-blue-400">{state.streamingContent.length} chars</span>
            </div>
            <div className="text-sm text-white max-h-24 overflow-y-auto">
              {state.streamingContent}
              <span className="inline-block w-2 h-4 bg-blue-400 ml-1 animate-pulse"></span>
            </div>
          </div>
        )}
        
        {state.error && (
          <div className="mt-2 p-2 bg-red-900/20 border border-red-500/30 rounded text-red-400 text-sm">
            {state.error}
            <button 
              onClick={handleReset}
              className="ml-2 text-red-300 hover:text-red-100 underline"
            >
              Try Again
            </button>
          </div>
        )}
      </div>

      {/* Content */}
      <div className="flex-1 overflow-auto">
        {React.Children.map(children, child => {
          if (React.isValidElement(child)) {
            return React.cloneElement(child, {
              // 注入通用 props 给子组件
              isProcessing: state.isProcessing,
              error: state.error,
              result: state.result,
              onProcess: handleProcess,
              onReset: handleReset,
              client,
              // 流式显示相关props
              streamingContent: state.streamingContent,
              streamingStatus: state.streamingStatus,
              isStreaming: state.isStreaming
            } as any);
          }
          return child;
        })}
      </div>
    </div>
  );
});

BaseSidebar.displayName = 'BaseSidebar';