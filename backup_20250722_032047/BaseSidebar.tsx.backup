/**
 * ============================================================================
 * åŸºç¡€ä¾§è¾¹æ ç»„ä»¶ (BaseSidebar.tsx)
 * ============================================================================
 * 
 * ã€æ ¸å¿ƒåŠŸèƒ½ã€‘
 * - æä¾›ç»Ÿä¸€çš„ä¾§è¾¹æ åŸºç¡€æ¶æ„
 * - ç®¡ç†AIå®¢æˆ·ç«¯è¿æ¥å’Œäº‹ä»¶ç›‘å¬
 * - å¤„ç†åº”ç”¨çº§åˆ«çš„æ¶ˆæ¯äº¤äº’å’ŒçŠ¶æ€ç®¡ç†
 * - æ”¯æŒæµå¼æ˜¾ç¤ºå’Œé”™è¯¯å¤„ç†
 * 
 * ã€å…³é”®ç›‘å¬äº‹ä»¶ã€‘
 * - streaming:start â†’ å¼€å§‹æµå¼æ˜¾ç¤º
 * - token:received â†’ æ¥æ”¶å®æ—¶token
 * - streaming:status â†’ çŠ¶æ€æ›´æ–°
 * - streaming:finish â†’ å®Œæˆæµå¼æ˜¾ç¤º
 * - message:received (ç¬¬168è¡Œ) â†’ æ¥æ”¶æœ€ç»ˆAIæ¶ˆæ¯
 * 
 * ã€æ¶ˆæ¯å¤„ç†é€»è¾‘ã€‘
 * ç¬¬168-198è¡Œï¼šç›‘å¬message:receivedäº‹ä»¶
 * åªæ›´æ–°å†…éƒ¨çŠ¶æ€ï¼Œä¸æ·»åŠ åˆ°èŠå¤©æ¶ˆæ¯æ•°ç»„
 * 
 * ã€æµå¼æ˜¾ç¤ºã€‘
 * ç¬¬260-271è¡Œï¼šæ˜¾ç¤ºå®æ—¶æµå¼å†…å®¹é¢„è§ˆ
 * åŒ…æ‹¬çŠ¶æ€æ–‡æœ¬å’Œå­—ç¬¦è®¡æ•°
 * 
 * ã€é‡è¦ã€‘è¿™é‡Œä¸ä¼šåˆ›å»ºèŠå¤©æ¶ˆæ¯ï¼Œåªå¤„ç†ä¾§è¾¹æ å†…éƒ¨çŠ¶æ€
 */
import React, { useState, useCallback, memo, useEffect } from 'react';
import { SimpleAIClient } from '../../services/SimpleAIClient';
import { useErrorHandler } from './ErrorBoundary';
import { validateUserInput, globalRateLimiter, generateSessionId } from '../../utils/security';
import { useAuth } from '../../hooks/useAuth';

export interface BaseSidebarProps {
  title: string;
  icon: string;
  triggeredInput?: string;
  onResult?: (result: any) => void;
  onError?: (error: Error) => void;
  children?: React.ReactNode;
  apiEndpoint?: string;
}

interface SidebarState {
  isProcessing: boolean;
  error: string | null;
  result: any;
  // æµå¼æ˜¾ç¤ºç›¸å…³çŠ¶æ€
  streamingContent: string;
  streamingStatus: string;
  isStreaming: boolean;
}

/**
 * é€šç”¨ Sidebar åŸºç¡€ç»„ä»¶
 * æä¾›ç»Ÿä¸€çš„çŠ¶æ€ç®¡ç†ã€é”™è¯¯å¤„ç†å’Œ AI å®¢æˆ·ç«¯ç®¡ç†
 */
export const BaseSidebar = memo<BaseSidebarProps>(({
  title,
  icon,
  triggeredInput,
  onResult,
  onError,
  children,
  apiEndpoint = process.env.REACT_APP_API_ENDPOINT || 'http://localhost:8080'
}) => {
  const [client] = useState(() => new SimpleAIClient(apiEndpoint));
  const { user } = useAuth();
  const [state, setState] = useState<SidebarState>({
    isProcessing: false,
    error: null,
    result: null,
    streamingContent: '',
    streamingStatus: '',
    isStreaming: false
  });
  
  const { handleError } = useErrorHandler();

  // è®¾ç½®æµå¼äº‹ä»¶ç›‘å¬å™¨
  useEffect(() => {
    if (!client) return;

    console.log(`ğŸ”— BASESIDEBAR [${title}]: Setting up streaming event listeners`);

    // ç›‘å¬æµå¼å¼€å§‹
    const unsubscribeStreamingStart = client.on('streaming:start', (data) => {
      console.log(`ğŸ¬ BASESIDEBAR [${title}]: Streaming started`, data);
      setState(prev => ({
        ...prev,
        isStreaming: true,
        streamingContent: '',
        streamingStatus: 'Connecting to AI...'
      }));
    });

    // ç›‘å¬å®æ—¶token (æ”¯æŒæ‰¹é‡å’Œå•ä¸ª)
    const unsubscribeToken = client.on('token:received', (data) => {
      // Optimize logging for batch processing
      if (data.count && data.count > 1) {
        console.log(`ğŸš€ BASESIDEBAR [${title}]: Batch received (${data.count} chars, total: ${data.total_index})`);
      } else {
        console.log(`ğŸ”¤ BASESIDEBAR [${title}]: Token received:`, data.content);
      }
      
      setState(prev => {
        const newContent = prev.streamingContent + (data.content || '');
        // Update status less frequently for batch processing
        const newStatus = data.count && data.count > 1 
          ? `Generating response... (${data.total_index || newContent.length} chars)`
          : 'Generating response...';
        
        return {
          ...prev,
          streamingContent: newContent,
          streamingStatus: newStatus
        };
      });
    });

    // ç›‘å¬çŠ¶æ€æ›´æ–°
    const unsubscribeStatus = client.on('streaming:status', (data) => {
      console.log(`ğŸ“Š BASESIDEBAR [${title}]: Status update:`, data.status);
      setState(prev => ({
        ...prev,
        streamingStatus: data.status || 'Processing...'
      }));
    });

    // ç›‘å¬æµå¼ç»“æŸ
    const unsubscribeStreamingFinish = client.on('streaming:finish', (data) => {
      console.log(`ğŸ BASESIDEBAR [${title}]: Streaming finished`, data);
      setState(prev => ({
        ...prev,
        isStreaming: false,
        streamingStatus: 'Completing...'
      }));
    });

    return () => {
      console.log(`ğŸ§¹ BASESIDEBAR [${title}]: Cleaning up streaming listeners`);
      unsubscribeStreamingStart?.();
      unsubscribeToken?.();
      unsubscribeStatus?.();
      unsubscribeStreamingFinish?.();
    };
  }, [client, title]);

  // ç»Ÿä¸€çš„å¤„ç†å‡½æ•°
  const handleProcess = useCallback(async (
    input: string,
    templateParams?: Record<string, any>,
    metadata?: Record<string, any>
  ) => {
    if (!input.trim()) return;

    // å®‰å…¨éªŒè¯
    const validation = validateUserInput(input);
    if (!validation.isValid) {
      setState(prev => ({ ...prev, error: validation.error || 'Invalid input' }));
      return;
    }

    // è¯·æ±‚é¢‘ç‡é™åˆ¶
    const sessionId = generateSessionId();
    const rateLimitCheck = globalRateLimiter.checkLimit(sessionId);
    if (!rateLimitCheck.allowed) {
      setState(prev => ({ ...prev, error: 'Too many requests. Please try again later.' }));
      return;
    }

    setState(prev => ({ 
      ...prev, 
      isProcessing: true, 
      error: null,
      streamingContent: '',
      streamingStatus: 'Preparing request...',
      isStreaming: false
    }));

    try {
      const requestMetadata = {
        sender: title.toLowerCase().replace(/\s+/g, '_'),
        template_parameters: templateParams,
        user_id: user?.user_id || 'anonymous',
        session_id: 'app_session',
        ...metadata
      };

      // ä½¿ç”¨æ¸…ç†åçš„è¾“å…¥
      const cleanInput = validation.sanitized || input;
      await client.sendMessage(cleanInput, requestMetadata);
      
      // è®¾ç½®æ¶ˆæ¯æ¥æ”¶ç›‘å¬å™¨
      const unsubscribe = client.on('message:received', (message) => {
        try {
          console.log('ğŸ“¨ BASESIDEBAR: Received message:', {
            title,
            sender: message.metadata?.sender,
            content: message.content?.substring(0, 100) + '...',
            isProcessing: true
          });
          
          setState(prev => ({ 
            ...prev, 
            isProcessing: false, 
            result: message,
            error: null 
          }));
          
          console.log('âœ… BASESIDEBAR: Set isProcessing to false for:', title);
          
          onResult?.(message);
          unsubscribe(); // æ¸…ç†ç›‘å¬å™¨
        } catch (error) {
          const err = error instanceof Error ? error : new Error(String(error));
          handleError(err, `${title} result processing`);
          onError?.(err);
          setState(prev => ({ 
            ...prev, 
            isProcessing: false, 
            error: err.message 
          }));
        }
      });

      // è®¾ç½®è¶…æ—¶æ¸…ç†
      setTimeout(() => {
        unsubscribe();
        if (state.isProcessing) {
          setState(prev => ({ 
            ...prev, 
            isProcessing: false, 
            error: 'Request timeout' 
          }));
        }
      }, 30000); // 30ç§’è¶…æ—¶

    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      handleError(err, `${title} request`);
      onError?.(err);
      setState(prev => ({ 
        ...prev, 
        isProcessing: false, 
        error: err.message 
      }));
    }
  }, [client, title, onResult, onError, handleError, state.isProcessing]);

  // é‡ç½®çŠ¶æ€
  const handleReset = useCallback(() => {
    setState({
      isProcessing: false,
      error: null,
      result: null,
      streamingContent: '',
      streamingStatus: '',
      isStreaming: false
    });
  }, []);

  // è‡ªåŠ¨å¤„ç†è§¦å‘è¾“å…¥
  React.useEffect(() => {
    if (triggeredInput && !state.isProcessing) {
      handleProcess(triggeredInput);
    }
  }, [triggeredInput, handleProcess, state.isProcessing]);

  return (
    <div className="h-full flex flex-col bg-black/20 backdrop-blur-xl">
      {/* Header */}
      <div className="p-6 border-b border-white/10">
        <div className="flex items-center gap-3 mb-2">
          <span className="text-2xl">{icon}</span>
          <h2 className="text-xl font-bold text-white">{title}</h2>
        </div>
        
        {state.isProcessing && (
          <div className="flex items-center gap-2 text-blue-400 text-sm">
            <div className="w-4 h-4 border-2 border-blue-400 border-t-transparent rounded-full animate-spin"></div>
            {state.isStreaming ? state.streamingStatus : 'Processing...'}
          </div>
        )}
        
        {/* æµå¼å†…å®¹é¢„è§ˆ (ä¼˜åŒ–ç‰ˆ) */}
        {state.isStreaming && state.streamingContent && (
          <div className="mt-3 p-3 bg-blue-500/10 border border-blue-500/20 rounded-lg">
            <div className="text-xs text-blue-300 mb-1 flex items-center justify-between">
              <span>Real-time Response:</span>
              <span className="text-blue-400">{state.streamingContent.length} chars</span>
            </div>
            <div className="text-sm text-white max-h-24 overflow-y-auto">
              {state.streamingContent}
              <span className="inline-block w-2 h-4 bg-blue-400 ml-1 animate-pulse"></span>
            </div>
          </div>
        )}
        
        {state.error && (
          <div className="mt-2 p-2 bg-red-900/20 border border-red-500/30 rounded text-red-400 text-sm">
            {state.error}
            <button 
              onClick={handleReset}
              className="ml-2 text-red-300 hover:text-red-100 underline"
            >
              Try Again
            </button>
          </div>
        )}
      </div>

      {/* Content */}
      <div className="flex-1 overflow-auto">
        {React.Children.map(children, child => {
          if (React.isValidElement(child)) {
            return React.cloneElement(child, {
              // æ³¨å…¥é€šç”¨ props ç»™å­ç»„ä»¶
              isProcessing: state.isProcessing,
              error: state.error,
              result: state.result,
              onProcess: handleProcess,
              onReset: handleReset,
              client,
              // æµå¼æ˜¾ç¤ºç›¸å…³props
              streamingContent: state.streamingContent,
              streamingStatus: state.streamingStatus,
              isStreaming: state.isStreaming
            } as any);
          }
          return child;
        })}
      </div>
    </div>
  );
});

BaseSidebar.displayName = 'BaseSidebar';