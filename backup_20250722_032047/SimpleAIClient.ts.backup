/**
 * ============================================================================
 * 简易AI客户端 (SimpleAIClient.ts)
 * ============================================================================
 * 
 * 【核心功能】
 * - 与后端API进行通信，支持文本和多模态消息
 * - 处理服务器推送事件(SSE)流式响应
 * - 解析批量token流和单token流(向后兼容)
 * - 管理消息生命周期和事件系统
 * 
 * 【流式事件处理】
 * - start事件 → 触发streaming:start
 * - response_batch事件 → 批量token处理(v3.0优化)
 * - response_token事件 → 单token处理(兼容)
 * - content事件 → 最终内容(目前被跳过)
 * - node_update事件 → 工作流状态 → streaming:status
 * - end事件 → 流结束清理
 * 
 * 【重要的事件映射】
 * node_update → streaming:status → StreamingHandler → updateStreamingStatus
 * response_batch → token:received → StreamingHandler → appendToStreamingMessage
 * 
 * 【消息处理逻辑】
 * 第306-318行：token完成时处理累积内容
 * 第324-326行：跳过content事件(只依赖token流)
 * 第372行：生成"Processing should_continue..."状态消息
 */

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
  metadata?: {
    sender?: string;
    app?: string;
    media_items?: Array<{
      type: string;
      url: string;
      title?: string;
    }>;
    [key: string]: any;
  };
}

type EventCallback = (data: any) => void;

export class SimpleAIClient {
  private apiEndpoint: string;
  private events: Map<string, EventCallback[]> = new Map();
  private destroyed: boolean = false;
  private activeRequests: Set<AbortController> = new Set();

  constructor(apiEndpoint: string = 'http://localhost:8080') {
    this.apiEndpoint = apiEndpoint;
    console.log('🔧 SimpleAI: Client created with endpoint:', apiEndpoint);
  }

  // Event system
  on(event: string, callback: EventCallback): () => void {
    if (this.destroyed) {
      console.warn('SimpleAI: Cannot add event listener - client is destroyed');
      return () => {};
    }

    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback);
    
    // Return cleanup function
    return () => {
      const callbacks = this.events.get(event);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) callbacks.splice(index, 1);
        
        // Clean up empty event arrays to prevent memory accumulation
        if (callbacks.length === 0) {
          this.events.delete(event);
        }
      }
    };
  }

  private emit(event: string, data: any) {
    if (this.destroyed) return;
    
    // Reduce console spam for frequent events
    if (event === 'token:received' && data.count && data.count > 1) {
      // Only log every 10th batch to reduce console spam
      if ((data.total_index || 0) % 100 === 0) {
        console.log(`🚀 SimpleAI: Batch emitting ${event}`, `total: ${data.total_index}`);
      }
    } else if (event !== 'token:received') {
      console.log(`🔥 SimpleAI: Emitting ${event}`, data);
    }
    
    const callbacks = this.events.get(event) || [];
    callbacks.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error('SimpleAI: Error in event callback:', error);
      }
    });
  }

  // 销毁客户端实例，清理所有资源
  destroy(): void {
    console.log('🧹 SimpleAI: Destroying client and cleaning up resources');
    
    this.destroyed = true;
    
    // 取消所有活跃的请求
    this.activeRequests.forEach(controller => {
      try {
        controller.abort();
      } catch (error) {
        console.warn('SimpleAI: Error aborting request:', error);
      }
    });
    this.activeRequests.clear();
    
    // 清理所有事件监听器
    this.events.clear();
    
    console.log('✅ SimpleAI: Client destroyed successfully');
  }

  // 检查客户端是否已销毁
  isDestroyed(): boolean {
    return this.destroyed;
  }

  // Send message (text only)
  async sendMessage(content: string, metadata: any = {}): Promise<string> {
    return this.sendMultimodalMessage(content, [], metadata);
  }

  // Send multimodal message with files
  async sendMultimodalMessage(content: string, files: File[] = [], metadata: any = {}): Promise<string> {
    console.log('🔍 SimpleAI: sendMultimodalMessage called, destroyed status:', this.destroyed);
    if (this.destroyed) {
      console.error('❌ SimpleAI: Client is destroyed, cannot send message');
      throw new Error('SimpleAI: Client is destroyed, cannot send message');
    }

    const messageId = `user-${Date.now()}`;
    const controller = new AbortController();
    this.activeRequests.add(controller);

    try {
      let response: Response;

      if (files.length === 0) {
        // Text-only request (JSON)
        response = await fetch(`${this.apiEndpoint}/api/chat`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message: content,
            session_id: metadata.session_id || 'default',
            user_id: metadata.user_id || 'test_user',
            use_streaming: true,
            template_parameters: metadata.template_parameters
          }),
          signal: controller.signal
        });
      } else {
        // Multimodal request (FormData)
        const formData = new FormData();
        formData.append('message', content);
        formData.append('session_id', metadata.session_id || 'default');
        formData.append('user_id', metadata.user_id || 'test_user');
        formData.append('use_streaming', 'true');

        // Add template parameters if provided
        if (metadata.template_parameters) {
          Object.entries(metadata.template_parameters).forEach(([key, value]) => {
            formData.append(`template_parameters[${key}]`, value as string);
          });
        }

        // Add files
        files.forEach((file, index) => {
          if (file.type.startsWith('audio/')) {
            formData.append('audio', file);
          } else {
            formData.append(`file_${index}`, file);
          }
        });

        console.log('🔄 SimpleAI: Sending multimodal request with', files.length, 'files');

        response = await fetch(`${this.apiEndpoint}/api/chat`, {
          method: 'POST',
          body: formData, // No Content-Type header for FormData
          signal: controller.signal
        });
      }

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      // Handle streaming response
      await this.handleStreamingResponse(response, messageId, metadata);
      
      return messageId;
    } catch (error) {
      console.error('❌ SimpleAI: Request failed', error);
      throw error;
    } finally {
      // 清理 controller 引用
      this.activeRequests.delete(controller);
    }
  }

  private async handleStreamingResponse(response: Response, requestId: string, metadata: any = {}) {
    if (!response.body) {
      throw new Error('No response body');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let accumulatedContent = '';
    let hasStartedStreaming = false;
    let isReceivingTokens = false;
    let totalTokens = 0;
    let messageProcessed = false; // 防止重复处理消息

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.trim() && line.startsWith('data: ')) {
            const dataContent = line.slice(6).trim();
            
            // Handle [DONE] marker
            if (dataContent === '[DONE]') {
              console.log('🔚 SimpleAI: Stream ended with [DONE] marker');
              if (isReceivingTokens) {
                this.emit('streaming:end', { type: 'done', totalTokens });
                this.emit('typing:changed', false);
              }
              continue;
            }
            
            try {
              const eventData = JSON.parse(dataContent);
              
              // Handle start event
              if (eventData.type === 'start') {
                console.log('🎬 SimpleAI: Stream session started');
                this.emit('streaming:start', { 
                  type: 'session_start', 
                  session_id: eventData.session_id,
                  trace_id: eventData.trace_id 
                });
                this.emit('typing:changed', true);
              }
              
              // Handle batch response tokens (优化版本 - 批量处理)
              else if (eventData.type === 'custom_event' && 
                       eventData.metadata?.raw_chunk?.response_batch) {
                
                const batchData = eventData.metadata.raw_chunk.response_batch;
                
                if (batchData.status === 'streaming' && batchData.tokens) {
                  console.log(`🚀 Batch #${batchData.start_index}-${batchData.start_index + batchData.count}: "${batchData.tokens}"`);
                  
                  if (!hasStartedStreaming) {
                    console.log('🎬 SimpleAI: Starting batch token streaming');
                    this.emit('streaming:start', { type: 'token_start' });
                    hasStartedStreaming = true;
                    isReceivingTokens = true;
                  }
                  
                  // 批量发送tokens用于实时显示
                  this.emit('token:received', { 
                    content: batchData.tokens,
                    start_index: batchData.start_index,
                    count: batchData.count,
                    total_index: batchData.total_index,
                    status: batchData.status
                  });
                  
                  // 积累内容用于最终处理
                  accumulatedContent += batchData.tokens;
                  totalTokens += batchData.count;
                }
              }
              
              // Handle single response tokens (向后兼容)
              else if (eventData.type === 'custom_event' && 
                       eventData.metadata?.raw_chunk?.response_token) {
                
                const tokenData = eventData.metadata.raw_chunk.response_token;
                
                if (tokenData.status === 'streaming' && tokenData.token) {
                  totalTokens++;
                  console.log(`🔤 Token #${tokenData.token_index}: "${tokenData.token}"`);
                  
                  if (!hasStartedStreaming) {
                    console.log('🎬 SimpleAI: Starting real-time token streaming');
                    this.emit('streaming:start', { type: 'token_start' });
                    hasStartedStreaming = true;
                    isReceivingTokens = true;
                  }
                  
                  // 立即发送每个token用于实时显示
                  this.emit('token:received', { 
                    content: tokenData.token,
                    index: tokenData.token_index,
                    status: tokenData.status
                  });
                  
                  // 同时积累内容用于最终处理
                  accumulatedContent += tokenData.token;
                  
                } else if (tokenData.status === 'completed') {
                  console.log(`🏁 SimpleAI: Token streaming completed. Total tokens: ${tokenData.total_tokens || totalTokens}`);
                  // 不创建新消息！让StreamingHandler的流式消息系统处理全部内容
                  console.log('✅ SimpleAI: Token streaming completed - letting StreamingHandler handle the message');
                  messageProcessed = true; // 标记已处理，避免其他地方重复处理
                  
                  // 流式显示完成，标记消息为完成状态
                  this.emit('streaming:finish', { totalTokens });
                  this.emit('typing:changed', false);
                  // 注意：不要立即重置hasStartedStreaming，等到end事件时再重置
                  isReceivingTokens = false;
                }
              }
              
              // Handle final content - 完全跳过，不发送任何最终消息
              else if (eventData.type === 'content') {
                console.log('🚫 SimpleAI: Final content received - COMPLETELY BLOCKED, no message:received event');
                console.log(`🔍 Debug: messageProcessed=${messageProcessed}, hasStartedStreaming=${hasStartedStreaming}, accumulatedContent=${accumulatedContent.length} chars`);
                // 不发送任何事件，完全依赖streaming系统
                messageProcessed = true;
              }
              
              // Handle end event
              else if (eventData.type === 'end') {
                console.log('🏁 SimpleAI: Stream session ended');
                console.log('✅ SimpleAI: Relying completely on StreamingHandler for message display');
                
                // 最终清理状态
                if (hasStartedStreaming || isReceivingTokens) {
                  this.emit('streaming:end', { type: 'session_end' });
                  this.emit('typing:changed', false);
                }
                
                // 重置所有流式状态
                isReceivingTokens = false;
                hasStartedStreaming = false;
                messageProcessed = true; // 标记已处理
                console.log('🧹 SimpleAI: All streaming state reset');
              }
              
              // Handle node updates (workflow progress)
              else if (eventData.type === 'node_update') {
                const nodeName = eventData.metadata?.node_name;
                const creditsUsed = eventData.metadata?.credits_used;
                const messagesCount = eventData.metadata?.messages_count;
                
                console.log(`🔄 SimpleAI: Node update - ${nodeName}`);
                
                // Start streaming message on the first meaningful node  
                if (!hasStartedStreaming && ['entry_preparation', 'reason_model'].includes(nodeName)) {
                  console.log('🎬 SimpleAI: Starting streaming on node update');
                  this.emit('streaming:start', { type: 'workflow_start', node: nodeName });
                  hasStartedStreaming = true;
                }
                
                // Map node names to user-friendly status messages
                const nodeStatusMap: Record<string, string> = {
                  'entry_preparation': '🔸 Preparing request...',
                  'reason_model': '🧠 Processing with AI...',
                  'should_continue': '🔄 Analyzing response...',
                  'call_tool': '🔧 Executing tools...',
                  'agent_executor': '🤖 Running autonomous tasks...',
                  'format_response': '📝 Formatting response...',
                  'memory_revision': '💾 Storing memory...'
                };
                
                const statusMessage = nodeStatusMap[nodeName] || `Processing ${nodeName}...`;
                
                this.emit('streaming:status', { 
                  status: statusMessage,
                  type: 'workflow', 
                  node: nodeName,
                  credits: creditsUsed,
                  messages: messagesCount
                });
              }
              
              // Handle tool execution events (minimal status updates)
              else if (eventData.type === 'tool_executing') {
                const toolName = eventData.metadata?.tool_name || 'tool';
                this.emit('streaming:status', { status: `Executing ${toolName}...`, type: 'tool' });
              }
              else if (eventData.type === 'tool_completed') {
                const toolName = eventData.metadata?.tool_name || 'tool';
                this.emit('streaming:status', { status: `Completed ${toolName}`, type: 'tool', tool_name: toolName });
              }
              
              // Handle tool result messages (contains actual tool output)
              else if (eventData.type === 'tool_result_msg') {
                try {
                  // Extract the tool result from the content
                  const content = eventData.content || '';
                  console.log('🔧 SimpleAI: Raw tool result content:', content);
                  
                  // Try multiple patterns to extract JSON
                  let jsonString = null;
                  
                  // Pattern 1: ToolMessage: {...} with potential line breaks
                  let jsonMatch = content.match(/ToolMessage:\s*(\{[\s\S]*\})/);
                  if (jsonMatch) {
                    jsonString = jsonMatch[1];
                  } else {
                    // Pattern 2: Just look for JSON object
                    jsonMatch = content.match(/(\{[\s\S]*\})/);
                    if (jsonMatch) {
                      jsonString = jsonMatch[1];
                    }
                  }
                  if (jsonString) {
                    // Clean up common JSON issues caused by streaming
                    jsonString = jsonString
                      .replace(/\\n/g, '')  // Remove escaped newlines that break JSON
                      .replace(/\n/g, '')   // Remove actual newlines
                      .replace(/,\s*}/g, '}')  // Remove trailing commas
                      .replace(/,\s*]/g, ']')  // Remove trailing commas in arrays
                      .trim();
                    
                    console.log('🔧 SimpleAI: Cleaned JSON string:', jsonString.substring(0, 200) + '...');
                    
                    const toolResult = JSON.parse(jsonString);
                    
                    // Generic tool result handler for all tools
                    console.log(`🔧 SimpleAI: Tool result for ${toolResult.action}:`, toolResult);
                    
                    // Emit generic tool result event
                    this.emit('tool:result', {
                      action: toolResult.action,
                      status: toolResult.status,
                      data: toolResult.data || {},
                      success: toolResult.status === 'success'
                    });
                    
                    // Special handling for image URLs if present
                    if (toolResult.data?.image_urls && toolResult.data.image_urls.length > 0) {
                      console.log('🖼️ SimpleAI: Found image URLs:', toolResult.data.image_urls);
                      this.emit('tool:images_found', { 
                        urls: toolResult.data.image_urls,
                        action: toolResult.action,
                        data: toolResult.data
                      });
                    }
                  } else {
                    console.log('⚠️ SimpleAI: No JSON found in tool result message');
                  }
                } catch (e) {
                  console.log('⚠️ SimpleAI: Error parsing tool result message:', e);
                  console.log('⚠️ SimpleAI: Raw content was:', eventData.content);
                }
              }
              
            } catch (parseError) {
              console.log('⚠️ SimpleAI: Failed to parse event:', {
                line,
                error: parseError,
                dataContent: dataContent?.substring(0, 500) + '...'
              });
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }


  private async processFinalResponseOLD(content: string, _requestId: string, metadata: any = {}) {
    try {
      // Check if we have any content to process
      if (!content.trim()) {
        console.log('⚠️ SimpleAI: No content to process in final response');
        return;
      }
      
      // Try to extract formatted_content if this is JSON wrapped
      let actualContent = this.extractFormattedContent(content);
      
      console.log('📦 SimpleAI: Processing content:', actualContent.substring(0, 200) + '...');
      
      // Extract image URLs and media items
      let media_items: any[] = [];
      
      // First, try to get media_items from the parsed JSON structure
      try {
        const parsedContent = JSON.parse(content);
        if (parsedContent.media_items && Array.isArray(parsedContent.media_items)) {
          media_items = parsedContent.media_items;
          console.log('🖼️ SimpleAI: Found media_items in parsed content:', media_items);
        }
      } catch (e) {
        // If not JSON, try to extract from markdown
        const imageUrls = this.extractImageUrls(actualContent);
        media_items = imageUrls.map(url => ({
          type: 'image',
          url: url,
          title: 'Generated Image'
        }));
      }
      
      // Use provided metadata directly
      const requestMetadata = metadata;
      
      // Create message with processed content
      const message: Message = {
        id: `assistant-${Date.now()}`,
        role: 'assistant',
        content: actualContent,
        timestamp: new Date().toISOString(),
        metadata: {
          ...requestMetadata,
          content_types: ['text'],
          has_media: media_items.length > 0,
          media_items: media_items
        }
      };

      console.log('💬 SimpleAI: Routing processed response to centralized store');
      console.log('🖼️ SimpleAI: Found', media_items.length, 'images in response');
      this.emit('message:received', message);
      
    } catch (parseError) {
      console.error('❌ SimpleAI: Failed to parse final response', parseError);
    }
  }

  private extractFormattedContent(content: string): string {
    try {
      // Try to parse as JSON first
      const parsedContent = JSON.parse(content);
      if (parsedContent.formatted_content) {
        console.log('✅ SimpleAI: Extracted formatted_content from JSON in processFinalResponse');
        return parsedContent.formatted_content;
      }
      
      // If it has formatted_content field but it's an object, try to stringify it
      if (typeof parsedContent.formatted_content === 'object') {
        return JSON.stringify(parsedContent.formatted_content, null, 2);
      }
      
      // Return the entire parsed content if no formatted_content field
      return typeof parsedContent === 'string' ? parsedContent : JSON.stringify(parsedContent, null, 2);
      
    } catch (jsonError) {
      // Not JSON, return content as-is
      console.log('📄 SimpleAI: Content is not JSON in processFinalResponse, using as-is');
      return content;
    }
  }

  private extractImageUrls(content: string): string[] {
    const imageUrls: string[] = [];
    
    // Match markdown image format: ![alt](url)
    const markdownImages = content.match(/!\[.*?\]\((https?:\/\/[^\s)]+)\)/g);
    if (markdownImages) {
      markdownImages.forEach(match => {
        const urlMatch = match.match(/\((https?:\/\/[^\s)]+)\)/);
        if (urlMatch) {
          imageUrls.push(urlMatch[1]);
        }
      });
    }
    
    // Match direct image URLs
    const directUrls = content.match(/https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp|svg)/gi);
    if (directUrls) {
      directUrls.forEach(url => {
        if (!imageUrls.includes(url)) {
          imageUrls.push(url);
        }
      });
    }
    
    console.log('🔍 SimpleAI: Extracted image URLs:', imageUrls);
    return imageUrls;
  }

}