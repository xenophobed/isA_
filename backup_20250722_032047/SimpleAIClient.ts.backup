/**
 * ============================================================================
 * ç®€æ˜“AIå®¢æˆ·ç«¯ (SimpleAIClient.ts)
 * ============================================================================
 * 
 * ã€æ ¸å¿ƒåŠŸèƒ½ã€‘
 * - ä¸åç«¯APIè¿›è¡Œé€šä¿¡ï¼Œæ”¯æŒæ–‡æœ¬å’Œå¤šæ¨¡æ€æ¶ˆæ¯
 * - å¤„ç†æœåŠ¡å™¨æ¨é€äº‹ä»¶(SSE)æµå¼å“åº”
 * - è§£ææ‰¹é‡tokenæµå’Œå•tokenæµ(å‘åå…¼å®¹)
 * - ç®¡ç†æ¶ˆæ¯ç”Ÿå‘½å‘¨æœŸå’Œäº‹ä»¶ç³»ç»Ÿ
 * 
 * ã€æµå¼äº‹ä»¶å¤„ç†ã€‘
 * - startäº‹ä»¶ â†’ è§¦å‘streaming:start
 * - response_batchäº‹ä»¶ â†’ æ‰¹é‡tokenå¤„ç†(v3.0ä¼˜åŒ–)
 * - response_tokenäº‹ä»¶ â†’ å•tokenå¤„ç†(å…¼å®¹)
 * - contentäº‹ä»¶ â†’ æœ€ç»ˆå†…å®¹(ç›®å‰è¢«è·³è¿‡)
 * - node_updateäº‹ä»¶ â†’ å·¥ä½œæµçŠ¶æ€ â†’ streaming:status
 * - endäº‹ä»¶ â†’ æµç»“æŸæ¸…ç†
 * 
 * ã€é‡è¦çš„äº‹ä»¶æ˜ å°„ã€‘
 * node_update â†’ streaming:status â†’ StreamingHandler â†’ updateStreamingStatus
 * response_batch â†’ token:received â†’ StreamingHandler â†’ appendToStreamingMessage
 * 
 * ã€æ¶ˆæ¯å¤„ç†é€»è¾‘ã€‘
 * ç¬¬306-318è¡Œï¼štokenå®Œæˆæ—¶å¤„ç†ç´¯ç§¯å†…å®¹
 * ç¬¬324-326è¡Œï¼šè·³è¿‡contentäº‹ä»¶(åªä¾èµ–tokenæµ)
 * ç¬¬372è¡Œï¼šç”Ÿæˆ"Processing should_continue..."çŠ¶æ€æ¶ˆæ¯
 */

interface Message {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: string;
  metadata?: {
    sender?: string;
    app?: string;
    media_items?: Array<{
      type: string;
      url: string;
      title?: string;
    }>;
    [key: string]: any;
  };
}

type EventCallback = (data: any) => void;

export class SimpleAIClient {
  private apiEndpoint: string;
  private events: Map<string, EventCallback[]> = new Map();
  private destroyed: boolean = false;
  private activeRequests: Set<AbortController> = new Set();

  constructor(apiEndpoint: string = 'http://localhost:8080') {
    this.apiEndpoint = apiEndpoint;
    console.log('ğŸ”§ SimpleAI: Client created with endpoint:', apiEndpoint);
  }

  // Event system
  on(event: string, callback: EventCallback): () => void {
    if (this.destroyed) {
      console.warn('SimpleAI: Cannot add event listener - client is destroyed');
      return () => {};
    }

    if (!this.events.has(event)) {
      this.events.set(event, []);
    }
    this.events.get(event)!.push(callback);
    
    // Return cleanup function
    return () => {
      const callbacks = this.events.get(event);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) callbacks.splice(index, 1);
        
        // Clean up empty event arrays to prevent memory accumulation
        if (callbacks.length === 0) {
          this.events.delete(event);
        }
      }
    };
  }

  private emit(event: string, data: any) {
    if (this.destroyed) return;
    
    // Reduce console spam for frequent events
    if (event === 'token:received' && data.count && data.count > 1) {
      // Only log every 10th batch to reduce console spam
      if ((data.total_index || 0) % 100 === 0) {
        console.log(`ğŸš€ SimpleAI: Batch emitting ${event}`, `total: ${data.total_index}`);
      }
    } else if (event !== 'token:received') {
      console.log(`ğŸ”¥ SimpleAI: Emitting ${event}`, data);
    }
    
    const callbacks = this.events.get(event) || [];
    callbacks.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error('SimpleAI: Error in event callback:', error);
      }
    });
  }

  // é”€æ¯å®¢æˆ·ç«¯å®ä¾‹ï¼Œæ¸…ç†æ‰€æœ‰èµ„æº
  destroy(): void {
    console.log('ğŸ§¹ SimpleAI: Destroying client and cleaning up resources');
    
    this.destroyed = true;
    
    // å–æ¶ˆæ‰€æœ‰æ´»è·ƒçš„è¯·æ±‚
    this.activeRequests.forEach(controller => {
      try {
        controller.abort();
      } catch (error) {
        console.warn('SimpleAI: Error aborting request:', error);
      }
    });
    this.activeRequests.clear();
    
    // æ¸…ç†æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
    this.events.clear();
    
    console.log('âœ… SimpleAI: Client destroyed successfully');
  }

  // æ£€æŸ¥å®¢æˆ·ç«¯æ˜¯å¦å·²é”€æ¯
  isDestroyed(): boolean {
    return this.destroyed;
  }

  // Send message (text only)
  async sendMessage(content: string, metadata: any = {}): Promise<string> {
    return this.sendMultimodalMessage(content, [], metadata);
  }

  // Send multimodal message with files
  async sendMultimodalMessage(content: string, files: File[] = [], metadata: any = {}): Promise<string> {
    console.log('ğŸ” SimpleAI: sendMultimodalMessage called, destroyed status:', this.destroyed);
    if (this.destroyed) {
      console.error('âŒ SimpleAI: Client is destroyed, cannot send message');
      throw new Error('SimpleAI: Client is destroyed, cannot send message');
    }

    const messageId = `user-${Date.now()}`;
    const controller = new AbortController();
    this.activeRequests.add(controller);

    try {
      let response: Response;

      if (files.length === 0) {
        // Text-only request (JSON)
        response = await fetch(`${this.apiEndpoint}/api/chat`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message: content,
            session_id: metadata.session_id || 'default',
            user_id: metadata.user_id || 'test_user',
            use_streaming: true,
            template_parameters: metadata.template_parameters
          }),
          signal: controller.signal
        });
      } else {
        // Multimodal request (FormData)
        const formData = new FormData();
        formData.append('message', content);
        formData.append('session_id', metadata.session_id || 'default');
        formData.append('user_id', metadata.user_id || 'test_user');
        formData.append('use_streaming', 'true');

        // Add template parameters if provided
        if (metadata.template_parameters) {
          Object.entries(metadata.template_parameters).forEach(([key, value]) => {
            formData.append(`template_parameters[${key}]`, value as string);
          });
        }

        // Add files
        files.forEach((file, index) => {
          if (file.type.startsWith('audio/')) {
            formData.append('audio', file);
          } else {
            formData.append(`file_${index}`, file);
          }
        });

        console.log('ğŸ”„ SimpleAI: Sending multimodal request with', files.length, 'files');

        response = await fetch(`${this.apiEndpoint}/api/chat`, {
          method: 'POST',
          body: formData, // No Content-Type header for FormData
          signal: controller.signal
        });
      }

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      // Handle streaming response
      await this.handleStreamingResponse(response, messageId, metadata);
      
      return messageId;
    } catch (error) {
      console.error('âŒ SimpleAI: Request failed', error);
      throw error;
    } finally {
      // æ¸…ç† controller å¼•ç”¨
      this.activeRequests.delete(controller);
    }
  }

  private async handleStreamingResponse(response: Response, requestId: string, metadata: any = {}) {
    if (!response.body) {
      throw new Error('No response body');
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let accumulatedContent = '';
    let hasStartedStreaming = false;
    let isReceivingTokens = false;
    let totalTokens = 0;
    let messageProcessed = false; // é˜²æ­¢é‡å¤å¤„ç†æ¶ˆæ¯

    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value, { stream: true });
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.trim() && line.startsWith('data: ')) {
            const dataContent = line.slice(6).trim();
            
            // Handle [DONE] marker
            if (dataContent === '[DONE]') {
              console.log('ğŸ”š SimpleAI: Stream ended with [DONE] marker');
              if (isReceivingTokens) {
                this.emit('streaming:end', { type: 'done', totalTokens });
                this.emit('typing:changed', false);
              }
              continue;
            }
            
            try {
              const eventData = JSON.parse(dataContent);
              
              // Handle start event
              if (eventData.type === 'start') {
                console.log('ğŸ¬ SimpleAI: Stream session started');
                this.emit('streaming:start', { 
                  type: 'session_start', 
                  session_id: eventData.session_id,
                  trace_id: eventData.trace_id 
                });
                this.emit('typing:changed', true);
              }
              
              // Handle batch response tokens (ä¼˜åŒ–ç‰ˆæœ¬ - æ‰¹é‡å¤„ç†)
              else if (eventData.type === 'custom_event' && 
                       eventData.metadata?.raw_chunk?.response_batch) {
                
                const batchData = eventData.metadata.raw_chunk.response_batch;
                
                if (batchData.status === 'streaming' && batchData.tokens) {
                  console.log(`ğŸš€ Batch #${batchData.start_index}-${batchData.start_index + batchData.count}: "${batchData.tokens}"`);
                  
                  if (!hasStartedStreaming) {
                    console.log('ğŸ¬ SimpleAI: Starting batch token streaming');
                    this.emit('streaming:start', { type: 'token_start' });
                    hasStartedStreaming = true;
                    isReceivingTokens = true;
                  }
                  
                  // æ‰¹é‡å‘é€tokensç”¨äºå®æ—¶æ˜¾ç¤º
                  this.emit('token:received', { 
                    content: batchData.tokens,
                    start_index: batchData.start_index,
                    count: batchData.count,
                    total_index: batchData.total_index,
                    status: batchData.status
                  });
                  
                  // ç§¯ç´¯å†…å®¹ç”¨äºæœ€ç»ˆå¤„ç†
                  accumulatedContent += batchData.tokens;
                  totalTokens += batchData.count;
                }
              }
              
              // Handle single response tokens (å‘åå…¼å®¹)
              else if (eventData.type === 'custom_event' && 
                       eventData.metadata?.raw_chunk?.response_token) {
                
                const tokenData = eventData.metadata.raw_chunk.response_token;
                
                if (tokenData.status === 'streaming' && tokenData.token) {
                  totalTokens++;
                  console.log(`ğŸ”¤ Token #${tokenData.token_index}: "${tokenData.token}"`);
                  
                  if (!hasStartedStreaming) {
                    console.log('ğŸ¬ SimpleAI: Starting real-time token streaming');
                    this.emit('streaming:start', { type: 'token_start' });
                    hasStartedStreaming = true;
                    isReceivingTokens = true;
                  }
                  
                  // ç«‹å³å‘é€æ¯ä¸ªtokenç”¨äºå®æ—¶æ˜¾ç¤º
                  this.emit('token:received', { 
                    content: tokenData.token,
                    index: tokenData.token_index,
                    status: tokenData.status
                  });
                  
                  // åŒæ—¶ç§¯ç´¯å†…å®¹ç”¨äºæœ€ç»ˆå¤„ç†
                  accumulatedContent += tokenData.token;
                  
                } else if (tokenData.status === 'completed') {
                  console.log(`ğŸ SimpleAI: Token streaming completed. Total tokens: ${tokenData.total_tokens || totalTokens}`);
                  // ä¸åˆ›å»ºæ–°æ¶ˆæ¯ï¼è®©StreamingHandlerçš„æµå¼æ¶ˆæ¯ç³»ç»Ÿå¤„ç†å…¨éƒ¨å†…å®¹
                  console.log('âœ… SimpleAI: Token streaming completed - letting StreamingHandler handle the message');
                  messageProcessed = true; // æ ‡è®°å·²å¤„ç†ï¼Œé¿å…å…¶ä»–åœ°æ–¹é‡å¤å¤„ç†
                  
                  // æµå¼æ˜¾ç¤ºå®Œæˆï¼Œæ ‡è®°æ¶ˆæ¯ä¸ºå®ŒæˆçŠ¶æ€
                  this.emit('streaming:finish', { totalTokens });
                  this.emit('typing:changed', false);
                  // æ³¨æ„ï¼šä¸è¦ç«‹å³é‡ç½®hasStartedStreamingï¼Œç­‰åˆ°endäº‹ä»¶æ—¶å†é‡ç½®
                  isReceivingTokens = false;
                }
              }
              
              // Handle final content - å®Œå…¨è·³è¿‡ï¼Œä¸å‘é€ä»»ä½•æœ€ç»ˆæ¶ˆæ¯
              else if (eventData.type === 'content') {
                console.log('ğŸš« SimpleAI: Final content received - COMPLETELY BLOCKED, no message:received event');
                console.log(`ğŸ” Debug: messageProcessed=${messageProcessed}, hasStartedStreaming=${hasStartedStreaming}, accumulatedContent=${accumulatedContent.length} chars`);
                // ä¸å‘é€ä»»ä½•äº‹ä»¶ï¼Œå®Œå…¨ä¾èµ–streamingç³»ç»Ÿ
                messageProcessed = true;
              }
              
              // Handle end event
              else if (eventData.type === 'end') {
                console.log('ğŸ SimpleAI: Stream session ended');
                console.log('âœ… SimpleAI: Relying completely on StreamingHandler for message display');
                
                // æœ€ç»ˆæ¸…ç†çŠ¶æ€
                if (hasStartedStreaming || isReceivingTokens) {
                  this.emit('streaming:end', { type: 'session_end' });
                  this.emit('typing:changed', false);
                }
                
                // é‡ç½®æ‰€æœ‰æµå¼çŠ¶æ€
                isReceivingTokens = false;
                hasStartedStreaming = false;
                messageProcessed = true; // æ ‡è®°å·²å¤„ç†
                console.log('ğŸ§¹ SimpleAI: All streaming state reset');
              }
              
              // Handle node updates (workflow progress)
              else if (eventData.type === 'node_update') {
                const nodeName = eventData.metadata?.node_name;
                const creditsUsed = eventData.metadata?.credits_used;
                const messagesCount = eventData.metadata?.messages_count;
                
                console.log(`ğŸ”„ SimpleAI: Node update - ${nodeName}`);
                
                // Start streaming message on the first meaningful node  
                if (!hasStartedStreaming && ['entry_preparation', 'reason_model'].includes(nodeName)) {
                  console.log('ğŸ¬ SimpleAI: Starting streaming on node update');
                  this.emit('streaming:start', { type: 'workflow_start', node: nodeName });
                  hasStartedStreaming = true;
                }
                
                // Map node names to user-friendly status messages
                const nodeStatusMap: Record<string, string> = {
                  'entry_preparation': 'ğŸ”¸ Preparing request...',
                  'reason_model': 'ğŸ§  Processing with AI...',
                  'should_continue': 'ğŸ”„ Analyzing response...',
                  'call_tool': 'ğŸ”§ Executing tools...',
                  'agent_executor': 'ğŸ¤– Running autonomous tasks...',
                  'format_response': 'ğŸ“ Formatting response...',
                  'memory_revision': 'ğŸ’¾ Storing memory...'
                };
                
                const statusMessage = nodeStatusMap[nodeName] || `Processing ${nodeName}...`;
                
                this.emit('streaming:status', { 
                  status: statusMessage,
                  type: 'workflow', 
                  node: nodeName,
                  credits: creditsUsed,
                  messages: messagesCount
                });
              }
              
              // Handle tool execution events (minimal status updates)
              else if (eventData.type === 'tool_executing') {
                const toolName = eventData.metadata?.tool_name || 'tool';
                this.emit('streaming:status', { status: `Executing ${toolName}...`, type: 'tool' });
              }
              else if (eventData.type === 'tool_completed') {
                const toolName = eventData.metadata?.tool_name || 'tool';
                this.emit('streaming:status', { status: `Completed ${toolName}`, type: 'tool', tool_name: toolName });
              }
              
              // Handle tool result messages (contains actual tool output)
              else if (eventData.type === 'tool_result_msg') {
                try {
                  // Extract the tool result from the content
                  const content = eventData.content || '';
                  console.log('ğŸ”§ SimpleAI: Raw tool result content:', content);
                  
                  // Try multiple patterns to extract JSON
                  let jsonString = null;
                  
                  // Pattern 1: ToolMessage: {...} with potential line breaks
                  let jsonMatch = content.match(/ToolMessage:\s*(\{[\s\S]*\})/);
                  if (jsonMatch) {
                    jsonString = jsonMatch[1];
                  } else {
                    // Pattern 2: Just look for JSON object
                    jsonMatch = content.match(/(\{[\s\S]*\})/);
                    if (jsonMatch) {
                      jsonString = jsonMatch[1];
                    }
                  }
                  if (jsonString) {
                    // Clean up common JSON issues caused by streaming
                    jsonString = jsonString
                      .replace(/\\n/g, '')  // Remove escaped newlines that break JSON
                      .replace(/\n/g, '')   // Remove actual newlines
                      .replace(/,\s*}/g, '}')  // Remove trailing commas
                      .replace(/,\s*]/g, ']')  // Remove trailing commas in arrays
                      .trim();
                    
                    console.log('ğŸ”§ SimpleAI: Cleaned JSON string:', jsonString.substring(0, 200) + '...');
                    
                    const toolResult = JSON.parse(jsonString);
                    
                    // Generic tool result handler for all tools
                    console.log(`ğŸ”§ SimpleAI: Tool result for ${toolResult.action}:`, toolResult);
                    
                    // Emit generic tool result event
                    this.emit('tool:result', {
                      action: toolResult.action,
                      status: toolResult.status,
                      data: toolResult.data || {},
                      success: toolResult.status === 'success'
                    });
                    
                    // Special handling for image URLs if present
                    if (toolResult.data?.image_urls && toolResult.data.image_urls.length > 0) {
                      console.log('ğŸ–¼ï¸ SimpleAI: Found image URLs:', toolResult.data.image_urls);
                      this.emit('tool:images_found', { 
                        urls: toolResult.data.image_urls,
                        action: toolResult.action,
                        data: toolResult.data
                      });
                    }
                  } else {
                    console.log('âš ï¸ SimpleAI: No JSON found in tool result message');
                  }
                } catch (e) {
                  console.log('âš ï¸ SimpleAI: Error parsing tool result message:', e);
                  console.log('âš ï¸ SimpleAI: Raw content was:', eventData.content);
                }
              }
              
            } catch (parseError) {
              console.log('âš ï¸ SimpleAI: Failed to parse event:', {
                line,
                error: parseError,
                dataContent: dataContent?.substring(0, 500) + '...'
              });
            }
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
  }


  private async processFinalResponseOLD(content: string, _requestId: string, metadata: any = {}) {
    try {
      // Check if we have any content to process
      if (!content.trim()) {
        console.log('âš ï¸ SimpleAI: No content to process in final response');
        return;
      }
      
      // Try to extract formatted_content if this is JSON wrapped
      let actualContent = this.extractFormattedContent(content);
      
      console.log('ğŸ“¦ SimpleAI: Processing content:', actualContent.substring(0, 200) + '...');
      
      // Extract image URLs and media items
      let media_items: any[] = [];
      
      // First, try to get media_items from the parsed JSON structure
      try {
        const parsedContent = JSON.parse(content);
        if (parsedContent.media_items && Array.isArray(parsedContent.media_items)) {
          media_items = parsedContent.media_items;
          console.log('ğŸ–¼ï¸ SimpleAI: Found media_items in parsed content:', media_items);
        }
      } catch (e) {
        // If not JSON, try to extract from markdown
        const imageUrls = this.extractImageUrls(actualContent);
        media_items = imageUrls.map(url => ({
          type: 'image',
          url: url,
          title: 'Generated Image'
        }));
      }
      
      // Use provided metadata directly
      const requestMetadata = metadata;
      
      // Create message with processed content
      const message: Message = {
        id: `assistant-${Date.now()}`,
        role: 'assistant',
        content: actualContent,
        timestamp: new Date().toISOString(),
        metadata: {
          ...requestMetadata,
          content_types: ['text'],
          has_media: media_items.length > 0,
          media_items: media_items
        }
      };

      console.log('ğŸ’¬ SimpleAI: Routing processed response to centralized store');
      console.log('ğŸ–¼ï¸ SimpleAI: Found', media_items.length, 'images in response');
      this.emit('message:received', message);
      
    } catch (parseError) {
      console.error('âŒ SimpleAI: Failed to parse final response', parseError);
    }
  }

  private extractFormattedContent(content: string): string {
    try {
      // Try to parse as JSON first
      const parsedContent = JSON.parse(content);
      if (parsedContent.formatted_content) {
        console.log('âœ… SimpleAI: Extracted formatted_content from JSON in processFinalResponse');
        return parsedContent.formatted_content;
      }
      
      // If it has formatted_content field but it's an object, try to stringify it
      if (typeof parsedContent.formatted_content === 'object') {
        return JSON.stringify(parsedContent.formatted_content, null, 2);
      }
      
      // Return the entire parsed content if no formatted_content field
      return typeof parsedContent === 'string' ? parsedContent : JSON.stringify(parsedContent, null, 2);
      
    } catch (jsonError) {
      // Not JSON, return content as-is
      console.log('ğŸ“„ SimpleAI: Content is not JSON in processFinalResponse, using as-is');
      return content;
    }
  }

  private extractImageUrls(content: string): string[] {
    const imageUrls: string[] = [];
    
    // Match markdown image format: ![alt](url)
    const markdownImages = content.match(/!\[.*?\]\((https?:\/\/[^\s)]+)\)/g);
    if (markdownImages) {
      markdownImages.forEach(match => {
        const urlMatch = match.match(/\((https?:\/\/[^\s)]+)\)/);
        if (urlMatch) {
          imageUrls.push(urlMatch[1]);
        }
      });
    }
    
    // Match direct image URLs
    const directUrls = content.match(/https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp|svg)/gi);
    if (directUrls) {
      directUrls.forEach(url => {
        if (!imageUrls.includes(url)) {
          imageUrls.push(url);
        }
      });
    }
    
    console.log('ğŸ” SimpleAI: Extracted image URLs:', imageUrls);
    return imageUrls;
  }

}